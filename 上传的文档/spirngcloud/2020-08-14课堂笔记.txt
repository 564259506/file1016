1. Eureka, Zookeeper, consul ,
      Eureka自我保护机制，好死不如赖活
背诵  Eureka工作流程（10条）
2.负载均衡： 轮询机制（默认）/权重机制
    常见的负载均衡有:Nginx、LVS硬件层面的有F5等
   权重机制：  P1    2
                     P2    1
                     P3    3           p1 p1  p2  p3 p3 p3 p1p1 p2 p3p3p3(...有几个搞几次)

3. 创建三个Eureka工程 ，选Web +Eureka service
配置文件： 分别在7001用引用7002和7003 ，7002中引用7001和7003.。。。
启动类上加注解（两个都可以@E。。。E。。。C。。/@E。。D。。C。。）

4.创建provide工程 : web +Eureka xx client
 端口号：8001
  配置文件中，指定注册中心的地址配上面的三个Eureka7001+7002+7003
  启动类上加注解（两个都可以。。。）
  写一个 service接口+service实现类
  写controller，
5. 自己写一个消费者 consumer
    创建consumer web+....client
    配置文件：端口号:9001
    其他配置信息同提供者：（服务提供者不要）
     启动类注释
     
 启动类中写@bean  public RestTemplate getRestTemplate(){
return new Re..}

写controller  private RestTemplate r..


二、WebService客户端：能使运行在不同机器上的不同应用无须附加第三方软件就可以相互交换数据或集成  （拿别人项目中的数据库中的数据！！！！！！！！）
     现在用 dubbo, eureka


LB:也就是LoadBlancer负载均衡，在微服务或分布式集群中常用的一种应用。
负载均衡简单的说就是将用户的请求平摊到多个服务器中，从而达到系统的HA
常见的负载均衡有:Nginx、LVS硬件层面的有F5等
响应的中间件有：dubbo、spring cloud等中均给我们提供了负载均衡

ribbon是NetFlix发布的开源项目，主要的功能是提供客户端软件负载均衡的算法，将NetFlix的中间服务件连接在一起，ribbon的客户端组件提供了一系列完善的配置和连接超时，重试等。简单的说就是在配置文件中列出

三：Feign是 服务接口调用
   是什么？ 一个声明式WebService客户端，使用Feign能让编写的WebService客户端更加简单，它的使用方法就是定义个接口，通过通过接口上添加注解来实现我们面向接口的服务调用
    Feign的作用？
​
①Feign使得编写java Http客户端变得更加容易
前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求进行封装处理，形成了一套调用方法，但是在实际的开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被在多处进行调用，所以我们通常会对每个微服务进行封装，封装出一些对外的接口，方便其他的微服务在需要的时候进行调用.所以Feign在此基础上做了进一步的封装，由它来帮助我们定义和实现依赖服务接口的定义
​
②在Feign的实现下，我们只需要创建一个接口并且使用注解来配置它@FeignClient，这样就简化了spring cloud ribbon,自动封装客户端调哪个客户端进行开发
​
③Feign集成了Ribbon
利用ribbon维护服务，并且通过轮询的方式实现了客户端的负载均衡。与ribbon不同的是：通过feign只需要定义指定的额接口声明方法，优雅而且简单的实现服务的调用

1. 创建项目（xxfeign） 勾选 web +xxxclient+openfeign
2.配置信息 端口，改名字，三台（7001，2，3）
3.主类注解两种（。。）
4.主类@Bean RestT..
5.controller(同消费者中的controller)   （先用原来的方式，等等做对比）
6.用feign的方式，同原来的方式做对比：
    6.1 先创建service, 顶上@feignClient("xxx(提供者的名字)")
    6.2 注意事项：6.2.1  不能使用@GetMapping或者@PostMapping
                           6.2.2 如果参数是基本数据类型，必须加@pathVariable进行绑定
                                   如果是pojo，必须加@RequestBody
   6.3service接口里面写controller需要的接口, @controller +@FeignClient("PROVIDER-01")
    6.4  然后写controller调用接口中方法（注意地址对应！！！跟提供者对应）
    6.5修改启动类中 @E。。feignClient
7. 把原本8001的provider改成8002（两个位置），然后打成jar包（老方法）

四、Hystrix：服务熔断  ----->用来解决服务雪崩
1.雪崩？？？   出现雪崩的问题
概念：服务雪崩
多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C调用其他的微服务,这就是所谓的服务“扇出”。如果扇出的时候，某个微服务调用的时候响应时间过长或者是不可用，对微服务A的调用就会产生影响，那么在调用服务A上所花的时间会非常的长，会占用越来越多的系统资源，从而导致系统崩溃，所谓的“雪崩效应”
​
对于高流量的应用，单一的后端依赖可能会导致所有的服务器上的资料都需要在几秒钟内完成，比失败更糟糕的是这些应用程序还可能会导致服务之间的延迟增加，备份队列，线程和其它系统资源的紧张，导致整个系统发生更多的级联故障。这些标识需要对故障和延迟进行隔离和管理，以便于单个应用依赖关系在发生故障的时候，不能影响到整个应用系统

2.什么是Hystrix？？？？
是一个用来处理分布式系统的延迟和容错的开源库
在分布式系统里，所有的微服务在调用的时候都有可能会出现失败的问题，比如说延迟加载问题。
Hystrix能保证在一个依赖出现故障的时候，不会导致整体服务失败或者是避免级联故障，以提高分布式系统的性能
​
Hystrix（断路器--类似家庭的保险丝）本身是一种开关设置，当某个服务单元发生故障以后，能通过断路器故障监控（保险丝），向调用方返回一个符合预期的，可处理备选响应（fallBack）而不是长时间的等待，这样的服务调用方不会被长时间的占用，从而避免了分布式系统中故障的蔓延（服务雪崩）

3. 解决雪崩方案
服务熔断
​
服务熔断机制是对应雪崩效应的一种微服务链路保护机制
当扇出的链路中某个微服务不可用或者是响应时间过长，会自动进行服务的降级。进而熔断该节点微服务的调用，快速返回“错误”的影响信息.
​
当检测该微服务节点调用正常后，恢复该链路的调用，在spring cloud框架里熔断机制是通过Hystrix实现的.Hystrix会监控微服务间的调用状况，当失败的调用到一定阈值，缺省是5秒20次调用失败就会启动熔断机制。
熔断机制的注解是@HystrixCommand

4. 创建hystrix模块   web+xxclient+Hystrix[Maintenance]
    配置文件 ：端口+ 名字+地址+xxtrue
    controller: xx
    service:xx
    serviceImpl:xxx
   主方法注释（三个）

5. 修改消费者中feign中的@FeignClient(xxxxxx)
                方法中的路径

服务熔断和服务降级的区别
  触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；
  管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）
  实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。
eureka + provider+consumer  +Ribbon(旧)
eureka +hystrix+feign

区分： callback: 回调函数  【跨域的时候 jsonp，用】
           rollback: 回滚  
           fallback ：失败返回
面试题： 跨域？？？？？

五。Zuul
Zuul包含了请求的路由和过滤这两个主要功能：
​
其中路由功能负责外部请求转发到具体的微服务实例上，是实现外部访问统一的入口基础。
而过滤器功能则是负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础
Zuul和eureka整合将zuul自身注册为eureka服务治理下的应用
同时eureka中获取到其他微服务的消息，也就是访问微服务都是zuul跳转后获得
新建工程：spring-cloud-zuul-gateway

Zuul: 第一代网关， gateway: 第二代网关
